const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

function forcedirSync(dir) {
    const sep = path.sep;
    const initDir = path.isAbsolute(dir) ? sep : '';
    dir.split(sep).reduce((parentDir, childDir) => {
        const curDir = path.resolve(parentDir, childDir);
        try {
            fs.mkdirSync(curDir);
        } catch (_) {
            // Ignore
        }

        return curDir;
    }, initDir);
}

function rmdirSyncForce(dir_path) {
    if (!fs.existsSync(dir_path))
        return;

    fs.readdirSync(dir_path).forEach(entry => {
        const entry_path = path.join(dir_path, entry);
        if (fs.lstatSync(entry_path).isDirectory()) {
            rmdirSyncForce(entry_path);
        } else {
            try {
                fs.unlinkSync(entry_path);
            } catch (_) {
                // Ignore
            }
        }
    });

    try {
        fs.rmdirSync(dir_path);
    } catch (_) {
        // Ignore
    }
}

function hash(data) {
    return crypto.createHash("sha256").update(data).digest().toString("hex").toUpperCase();
}

class GPKManager {
    constructor(GPKFolderName) {
        this.GPKFolderName = GPKFolderName;
        this.installedFiles = {};
        this.hasShownSymlinkWarning = false;
    }

    destructor() {

    }

    getGPKFolderPath(clientFolder) {
        return path.join(clientFolder, 'S1Game', 'CookedPC', this.GPKFolderName);
    }

    getFullPath(clientFolder, filename) {
        return path.join(this.getGPKFolderPath(clientFolder), filename);
    }

    initialize(clientFolder) {
        if (this.hasInstalled(clientFolder))
            return;

        rmdirSyncForce(this.getGPKFolderPath(clientFolder));
    }

    hasInstalled(clientFolder) {
        const folder = this.getGPKFolderPath(clientFolder);
        return Object.keys(this.installedFiles).some(filename => filename.startsWith(folder));
    }

    getInstalled(clientFolder) {
        const folder = this.getGPKFolderPath(clientFolder);
        return Object.keys(this.installedFiles).filter(filename => filename.startsWith(folder));
    }

    install(clientFolder, filename, fromPath) {
        const fromContents = fs.readFileSync(fromPath);
        const fromHash = hash(fromContents);

        const fullPath = this.getFullPath(clientFolder, filename);
        if (this.installedFiles[fullPath]) {
            if (this.installedFiles[fullPath].hash !== fromHash)
                throw new Error(`Trying to install two different GPK files with the same name: ${fullPath}`);

            ++this.installedFiles[fullPath].count;
        } else {
            forcedirSync(path.dirname(fullPath));

            try {
                fs.symlinkSync(fromPath, fullPath, 'file');
            } catch (e) {
                switch (e.code) {
                    case 'EISDIR': {
                        if (!this.hasShownSymlinkWarning) {
                            this.hasShownSymlinkWarning = true;
                            console.log('[toolbox] WARNING: It looks like either TERA Toolbox or the game are located on a drive / partition that does');
                            console.log('[toolbox] WARNING: not support symbolic links (for example because it is formatted using exFAT or FAT32)!');
                            console.log('[toolbox] WARNING: As a fallback, your client mods will be installed by creating file copies instead.');
                            console.log('[toolbox] WARNING: Note that this might slow down your client startup time and put strain on your disk!');
                        }

                        fs.copyFileSync(fromPath, fullPath);
                        break;
                    }
                    default: {
                        throw e;
                    }
                }
            }

            this.installedFiles[fullPath] = {
                hash: fromHash,
                count: 1,
            };
        }
    }

    uninstall(clientFolder, filename) {
        this._uninstall(this.getFullPath(clientFolder, filename));
    }

    _uninstall(fullPath) {
        if (!this.installedFiles[fullPath])
            return;

        if (this.installedFiles[fullPath].count > 1) {
            --this.installedFiles[fullPath].count;
        } else {
            try {
                fs.unlinkSync(fullPath);
            } catch (e) {
                console.log('[toolbox] WARNING: Unable to remove the following client mod file:');
                console.log(`[toolbox] WARNING: ${fullPath}`);
                console.log('[toolbox] WARNING: It will be deleted next time you start the game, instead. You can also delete it manually.');
            }
            delete this.installedFiles[fullPath];
        }
    }

    uninstallAll(clientFolder) {
        this.getInstalled(clientFolder).forEach(fullPath => this._uninstall(fullPath));
        if (!this.hasInstalled(clientFolder))
            rmdirSyncForce(this.getGPKFolderPath(clientFolder));
    }
}

module.exports = GPKManager;
